<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QR-friendly Minesweeper (single file)</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#60a5fa;--muted:#94a3b8;--success:#10b981}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,var(--bg),#071027);color:#e6eef8;display:flex;align-items:center;justify-content:center;padding:20px}
    .app{width:100%;max-width:950px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;padding:18px;box-shadow:0 8px 30px rgba(2,6,23,0.7)}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between}
    header h1{font-size:18px;margin:0}
    .controls{display:flex;gap:8px;align-items:center}
    input[type=text]{padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    select,button{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    main{display:grid;grid-template-columns:1fr 320px;gap:16px;margin-top:14px}
    .board-wrap{background:rgba(255,255,255,0.02);padding:14px;border-radius:10px;min-height:360px}
    .status{display:flex;gap:12px;align-items:center;margin-bottom:8px}
    .grid{display:inline-grid;border-radius:6px;user-select:none}
    .cell{width:32px;height:32px;display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(0,0,0,0.15));font-weight:700}
    .cell.hidden{background:linear-gradient(180deg,#0b2238,#031027);cursor:pointer}
    .cell.flag{background:linear-gradient(180deg,#3b2f6b,#261a4a)}
    .cell.mine{background:linear-gradient(180deg,#8b1e1e,#4a0f0f)}
    .cell.revealed{background:linear-gradient(180deg,#0b1220,#05223a);cursor:default}
    .sidebar{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;min-height:360px}
    .leaderboard{margin-top:10px}
    .leaderboard ol{padding-left:18px;margin:8px 0}
    footer{margin-top:12px;font-size:13px;color:var(--muted)}
    @media (max-width:900px){main{grid-template-columns:1fr} .sidebar{order:2}}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>QR Minesweeper â€” Single file</h1>
      <div class="controls">
        <input id="playerName" type="text" placeholder="Your name" maxlength="20">
        <select id="difficulty">
          <option value="beginner">Beginner (9x9, 10 mines)</option>
          <option value="intermediate">Intermediate (16x16, 40 mines)</option>
          <option value="expert">Expert (16x30, 99 mines)</option>
          <option value="custom">Custom</option>
        </select>
        <button id="startBtn">Start</button>
      </div>
    </header>

    <main>
      <div class="board-wrap">
        <div class="status">
          <div>Mines: <span id="minesLeft">0</span></div>
          <div>Time: <span id="timer">0</span>s</div>
          <div id="message" style="color:var(--muted)"></div>
        </div>
        <div id="gridContainer"></div>
        <footer>Left click to reveal â€” Right click to flag. Long-press on mobile to flag.</footer>
      </div>

      <aside class="sidebar">
        <div><strong>Score & Leaderboard</strong></div>
        <p style="color:var(--muted);font-size:13px">Your top local high scores are stored in your browser. To share a public leaderboard you'll need to configure a server (instructions below).</p>
        <div style="margin-top:8px">
          <div><label>Last score: </label><span id="lastScore">â€”</span></div>
          <div style="margin-top:6px"><label>Top local:</label>
            <div class="leaderboard" id="leaderboard"></div>
          </div>
        </div>

        <hr style="margin:10px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)">
        <div>
          <strong>Optional public leaderboard</strong>
          <p style="color:var(--muted);font-size:13px">If you host a simple endpoint that accepts POST /scores and GET /scores.json (CORS enabled), the game can push and fetch global highs. See code comments in the file for details.</p>
        </div>
      </aside>
    </main>
  </div>

  <script>
  // ======= Configuration =======
  // If you have your own leaderboard server with CORS enabled, set remoteLeaderboardUrl.
  // It should accept POST {name,score,time,difficulty,date} and return JSON list on GET.
  const remoteLeaderboardUrl = null; // e.g. 'https://yourdomain.com/scores'

  // ======= Game logic =======
  const presets = {
    beginner:{rows:9,cols:9,mines:10,mult:1},
    intermediate:{rows:16,cols:16,mines:40,mult:2},
    expert:{rows:16,cols:30,mines:99,mult:3}
  }

  let rows=9,cols=9,mines=10;
  let grid = [];
  let revealedCount = 0;
  let flags = 0;
  let minesLeft = mines;
  let timerInterval = null;
  let timeElapsed = 0;
  let started=false;
  let gameOver=false;

  const gridContainer = document.getElementById('gridContainer');
  const minesLeftEl = document.getElementById('minesLeft');
  const timerEl = document.getElementById('timer');
  const messageEl = document.getElementById('message');
  const startBtn = document.getElementById('startBtn');
  const diffSelect = document.getElementById('difficulty');
  const playerNameInput = document.getElementById('playerName');
  const lastScoreEl = document.getElementById('lastScore');
  const leaderboardEl = document.getElementById('leaderboard');

  function setDifficultyFromSelect(){
    const v = diffSelect.value;
    if(v==='custom'){
      rows = 12; cols = 12; mines = 20; // sensible default for custom
    } else {
      const p = presets[v]; rows = p.rows; cols = p.cols; mines = p.mines;
    }
    minesLeft = mines; minesLeftEl.textContent = minesLeft;
  }

  function startGame(){
    setDifficultyFromSelect();
    grid = Array(rows).fill(null).map(()=>Array(cols).fill().map(()=>({mine:false,adj:0,revealed:false,flag:false})));
    revealedCount = 0; flags = 0; minesLeft = mines; timeElapsed=0; started=false; gameOver=false; messageEl.textContent='';
    clearInterval(timerInterval); timerEl.textContent='0'; minesLeftEl.textContent=minesLeft;
    renderGrid();
  }

  function placeMines(safeR,safeC){
    let placed=0; while(placed<mines){
      const r=Math.floor(Math.random()*rows); const c=Math.floor(Math.random()*cols);
      if(grid[r][c].mine) continue;
      // don't place a mine on the first revealed cell or its neighbors (avoid immediate loss)
      if(Math.abs(r-safeR)<=1 && Math.abs(c-safeC)<=1) continue;
      grid[r][c].mine=true; placed++;
    }
    for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){
      if(grid[r][c].mine) continue;
      let adj=0;
      for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){
        const nr=r+dr,nc=c+dc; if(nr<0||nc<0||nr>=rows||nc>=cols) continue; if(grid[nr][nc].mine) adj++;
      }
      grid[r][c].adj = adj;
    }
  }

  function renderGrid(){
    gridContainer.innerHTML='';
    const gridEl = document.createElement('div');
    gridEl.className='grid';
    gridEl.style.gridTemplateColumns = `repeat(${cols},32px)`;
    gridEl.style.gridGap = '2px';
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = document.createElement('div');
        cell.className='cell hidden';
        cell.dataset.r=r; cell.dataset.c=c;
        cell.addEventListener('click', onCellClick);
        cell.addEventListener('contextmenu', onCellRightClick);
        // mobile long-press to flag
        let pressTimer=null;
        cell.addEventListener('touchstart', (e)=>{ pressTimer = setTimeout(()=>{ onCellRightClick(e); },600); });
        cell.addEventListener('touchend', ()=>{ if(pressTimer) clearTimeout(pressTimer); });
        gridEl.appendChild(cell);
      }
    }
    gridContainer.appendChild(gridEl);
  }

  function onCellClick(e){
    if(gameOver) return; const r=+this.dataset.r, c=+this.dataset.c;
    if(!started){ placeMines(r,c); started=true; startTimer(); }
    const cell = grid[r][c]; if(cell.revealed || cell.flag) return;
    revealCell(r,c);
    checkWin();
  }

  function onCellRightClick(e){ e.preventDefault(); if(gameOver) return; const target = e.currentTarget || e.target; const r=+target.dataset.r, c=+target.dataset.c; const cell = grid[r][c];
    if(!started){ placeMines(r,c); started=true; startTimer(); }
    if(cell.revealed) return;
    cell.flag = !cell.flag; const el = target;
    if(cell.flag){ el.classList.remove('hidden'); el.classList.add('flag'); el.textContent='âš‘'; flags++; minesLeft--; }
    else { el.classList.remove('flag'); el.classList.add('hidden'); el.textContent=''; flags--; minesLeft++; }
    minesLeftEl.textContent = minesLeft;
  }

  function revealCell(r,c){
    const cell = grid[r][c]; if(cell.revealed || cell.flag) return;
    cell.revealed = true; revealedCount++;
    const el = getCellEl(r,c);
    el.classList.remove('hidden'); el.classList.add('revealed'); el.textContent='';
    if(cell.mine){ el.classList.add('mine'); el.textContent='ðŸ’£'; loseGame(); return; }
    if(cell.adj>0){ el.textContent = cell.adj; el.style.color = numberColor(cell.adj); }
    else {
      // flood fill
      for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){
        const nr=r+dr,nc=c+dc; if(nr<0||nc<0||nr>=rows||nc>=cols) continue; if(!grid[nr][nc].revealed) revealCell(nr,nc);
      }
    }
  }

  function numberColor(n){ const colors=['#1e90ff','#10b981','#f59e0b','#ef4444','#7c3aed','#db2777','#14b8a6','#64748b']; return colors[(n-1)%colors.length]; }

  function getCellEl(r,c){ const gridEl = gridContainer.querySelector('.grid'); const idx = r*cols + c; return gridEl.children[idx]; }

  function startTimer(){ timerInterval = setInterval(()=>{ timeElapsed++; timerEl.textContent = timeElapsed; },1000); }

  function loseGame(){ gameOver=true; clearInterval(timerInterval); revealAllMines(); messageEl.style.color='var(--muted)'; messageEl.textContent='You hit a mine â€” game over!'; saveLastScore(0,false); }

  function revealAllMines(){ for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){ if(grid[r][c].mine){ const el=getCellEl(r,c); el.classList.remove('hidden'); el.classList.add('revealed','mine'); el.textContent='ðŸ’£'; } }}

  function checkWin(){
    const totalSafe = rows*cols - mines;
    if(revealedCount >= totalSafe){ gameOver=true; clearInterval(timerInterval); messageEl.style.color='var(--success)'; messageEl.textContent='You cleared the board â€” you win!'; const score = computeScore(); saveLastScore(score,true); }
  }

  function computeScore(){
    // score formula: higher is better. Depends on difficulty multiplier and speed.
    const diff = diffSelect.value;
    const mult = presets[diff]?.mult || 1;
    const base = (rows*cols - mines) * 50;
    const timeFactor = Math.max(1, 1 + (300 - timeElapsed)/300); // faster gives slightly bigger multiplier
    const score = Math.round(base * mult * timeFactor);
    return score;
  }

  // ======= Local leaderboard storage =======
  function loadLocalLeaderboard(){ const raw = localStorage.getItem('ms_highscores'); return raw ? JSON.parse(raw) : []; }
  function saveLocalLeaderboard(list){ localStorage.setItem('ms_highscores', JSON.stringify(list)); }

  function saveLastScore(score,won){ const name = (playerNameInput.value || 'Anonymous').slice(0,20); const entry = {name,score,time:timeElapsed,rows,cols,mines,difficulty:diffSelect.value,date:new Date().toISOString(),won};
    // display last
    lastScoreEl.textContent = score + (won? ' (win)':' (loss)');
    // save to local list if score > 0
    if(score>0){ const list = loadLocalLeaderboard(); list.push(entry); list.sort((a,b)=>b.score-a.score); saveLocalLeaderboard(list.slice(0,50)); renderLocalLeaderboard(); }
    // optionally push to remote
    if(remoteLeaderboardUrl){ try{ fetch(remoteLeaderboardUrl, {method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(entry)}).catch(()=>{}); }catch(e){}
    }
  }

  function renderLocalLeaderboard(){ const list = loadLocalLeaderboard(); if(list.length===0){ leaderboardEl.innerHTML='<div style="color:var(--muted)">No local scores yet.</div>'; return; }
    const ol = document.createElement('ol'); for(let i=0;i<Math.min(10,list.length);i++){ const it=list[i]; const li = document.createElement('li'); li.textContent = `${it.name} â€” ${it.score} pts â€” ${it.difficulty} â€” ${new Date(it.date).toLocaleString()}`; ol.appendChild(li);} leaderboardEl.innerHTML=''; leaderboardEl.appendChild(ol);
  }

  // ======= UI wiring =======
  startBtn.addEventListener('click', ()=>{ startGame(); });
  diffSelect.addEventListener('change', ()=>{ setDifficultyFromSelect(); startGame(); });

  // init
  setDifficultyFromSelect(); startGame(); renderLocalLeaderboard();

  // optional: fetch remote leaderboard if configured
  if(remoteLeaderboardUrl){ (async ()=>{ try{ const res = await fetch(remoteLeaderboardUrl); if(res.ok){ const data = await res.json(); // expected: array of {name,score,...}
        // merge top remote entries into shown leaderboard
        const local = loadLocalLeaderboard(); const merged = (data || []).concat(local); merged.sort((a,b)=>b.score-a.score); saveLocalLeaderboard(merged.slice(0,50)); renderLocalLeaderboard(); } }catch(e){} })(); }

  // convenience: allow keyboard R to restart
  document.addEventListener('keydown',(e)=>{ if(e.key.toLowerCase()==='r') startGame(); });
  </script>
</body>
</html>
